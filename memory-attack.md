### 内存攻击
- 内存攻击指的是攻击者利用软件安全漏洞，构造恶意输入导致软件在处理输入数据时出现非预期错误
- 将输入数据写入内存中的某些特定敏感位置，从而劫持软件控制流，转而执行外部输入的指令代码，造成目标系统被获取远程控制或拒绝服务
- 内存攻击的表面原因是软件编写错误，诸如过滤输入的条件设置缺陷、变量类型转换错误、逻辑判断错误、指针引用错误等
- 但究其根本原因，是现代电子计算机在实现图灵机模型时，没有在内存中严格区分数据和指令，这就存在外部输入数据成为指令代码从而被执行的可能
- 任何操作系统级别的防护措施都不可能完全根除现代计算机体系结构上的这个弊端，只能试图去阻止攻击者利用 (Exploit)

### 缓冲区溢出漏洞机理
- 缓冲区溢出 (Buffer Overflow 或 Buffer Overrun) 漏洞是程序由于缺乏对缓冲区边界条件检查而引起的一种异常行为
- 通常是程序向缓冲区中写数据，但内容超过了设定的缓冲区边界，从而覆盖了相邻的内存区域
- 造成覆盖程序中的其他变量甚至影响控制流的敏感数据，造成程序的非预期行为
- 一般根据缓冲区溢出的内存位置不同，将缓冲区溢出又分为 栈溢出 (Stack Overflow) 与 堆溢出 (Heap Overflow)

### 栈溢出利用原理
程序执行过程中的栈，是由操作系统创建和维护的，同时也支持了程序内的函数调用功能
在进行函数调用时，程序会将返回地址压入栈中，而执行完被调用的函数代码后，则会通过 ret 指令从栈中弹出返回地址，装载到 EIP 指令寄存器，从而继续程序运行
然而这种将控制程序流程的敏感数据与程序变量同时保存在同一段内存空间中的冯诺依曼体系，必然会给缓冲区溢出攻击带来本质上的可行性
栈溢出发生在程序向位于栈中的内存地址写数据时，当写入的数据长度超过栈分配给缓冲区的空间时，就会造成栈溢出
从栈溢出的原理出发，攻击者可以找到如下三种方式来利用这种类型的漏洞:
- 覆盖缓冲区附近的程序变量：改变程序的执行流程和结果
- 覆盖栈中保存的函数返回地址：修改为攻击者指定的地址，当程序返回时，程序流程将跳转到攻击者指定地址，理想情况下可以执行任意代码
- 覆盖某个函数指针或程序异常处理结构：只要溢出之后目标函数或异常处理例程被执行，同样可以让程序流程跳转到任意地址

#### 覆盖函数返回地址利用方式
- 函数调用是程序中最常见的命令，程序调用函数时，程序流程将暂时转到被调用的函数，函数执行完之后再跳转回原来的位置
- 所以在执行调用函数前需要保存下一跳指令的地址，让程序在执行完函数调用后能够从这个指令地址处继续执行

```c
#inclide <string.h>
void foo (char *bar) {
	char c[8];
	strcpy(c, bar);	//没有进行边界检查，从而存在栈溢出漏洞
}

int main () {
	char array[] = "ABCDABCDABCD\x18\xFF\x18\x00"
	foo(array);	//调用函数
	return 0;
}
```

#### 覆盖异常处理结构利用方式
程序在运行过程中可能会发生一些异常，比如除 0 计算、访问无效内存地址等，此时就需要正常指令序列之外的代码处理这些异常
Windows 提供结构化异常处理机制 SEH，可以利用程序自定义的异常处理函数或者操作系统默认的处理函数处理异常
异常处理结构以链表形式春促在栈中，寄存器 FS 指向当前活动线程的 TEB (线程环境块) 结构
- 指向下一异常处理结构体的指针
- 异常处理函数 SEH 例程的地址
栈溢出之后覆盖异常处理结构的利用方式，就是用特定地址覆盖栈中异常处理结构体中的异常处理函数指针，并处罚异常，导致去加载篡改之后的处理函数指针

### 堆溢出利用原理
不同于栈，堆是程序运行时动态分配的内存，用户通过 malloc、new 等函数申请内存，通过返回的起始地址指针对分配的内存进行操作，使用完后要通过 free、delete 等函数释放这部分内存，否则会造成内存泄露
操作分为分配、释放、合并三种
因为堆在内存中位置不固定，大小比较自由，多次申请、释放后可能会更加凌乱，系统从性能、空间利用率还有越来越受到重视的安全角度出发，来管理堆，具体实现比较复杂
```c
void DeleteBlock (DListBlock *p) {
	p->next->previous = p->previous;
	p->previous->next = p->next;
}
```
